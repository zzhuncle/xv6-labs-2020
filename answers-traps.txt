1. a0~a7存储了函数调用的参数，13被存在了a2寄存器中（根据45行代码）
2. 看不到，g(x) 被内联到 f(x) 中，然后 f(x) 又被进一步内联到 main() 中。
    所以看到的不是函数跳转，而是优化后的内联函数。
3. 0x0000000000000628，可以通过查找printf或者通过auipc	ra,0x0 jalr	1528(ra)两条汇编指令计算得到
4. 0x0000000000000038, jalr 指令会将 pc + 4 赋给当前寄存器，刚好是其下一条指令的地址
5. ％x 表示以十六进制数形式输出整数，57616 的16进制表示就是 e110，与大小端序无关。
   %s 是输出字符串，以整数 i 所在的开始地址，按照字符的格式读取字符，
   直到读取到 '\0' 为止。当是小端序表示的时候，内存中存放的数是：72 6c 64 00，
   刚好对应rld。当是大端序的时候，则反过来了，因此需要将 i 以16进制数的方式逆转一下。
6. 答案不是一个具体的值，
   printf 接收到了两个参数，但实际需要三个参数，最后一个参数是放在 a2 寄存器中，
   由于没有输入第三个参数，因此 a2 寄存器中目前有啥就输出啥。
